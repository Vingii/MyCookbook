@page "/recipe/{Name}"
@using MyCookbook.Components;
@using MyCookbook.Data
@using MyCookbook.Data.CookbookDatabase
@using Microsoft.Extensions.Localization;
@using MyCookbook.Services;
@using System.Security.Claims;
@inject ILanguageDictionary LanguageDictionary
@inject IStringLocalizer<RecipeViewer> Localizer
@inject ILogger<RecipeViewer> Logger
@inject LanguageNotifier LanguageNotifier
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject IDialogService DialogService
@inherits OwningComponentBase<CookbookDatabaseService>
@implements IDisposable

<link rel="stylesheet" href="css/RecipeViewer.css">

<PageTitle>Recipe - @Name</PageTitle>
<div class="d-flex align-center gap-4">
    <MudText Class="ma-2" Typo="Typo.h3">@Name</MudText>
    <MudButton Style="margin-left: auto" OnClick="@(async() => await ShareRecipe())" Variant="Variant.Filled" Color="Color.Primary">@Localizer["Share"]</MudButton>
</div>
<hr />

<AuthorizeView>
    <Authorized>
        <MudSlider @bind-Value="Servings" Min="1" Max="10" TickMarks="true" Color="Color.Info">
            @Localizer["Servings"]: @_recipe.Servings
        </MudSlider>
        <br />
        <MudGrid>
            <MudItem sm="12" md="6">
                <MudTable @ref="_ingredientTable" Items="@_recipe.Ingredients.OrderBy(x => x.Order)" Hover="true" Breakpoint="Breakpoint.None" Loading="@_loading" LoadingProgressColor="Color.Info" Dense="true"
                      RowEditCommit="CommitTableEdit" CanCancelEdit="true" OnPreviewEditClick="PreviewEditClick" T="Ingredient"
                      EditButtonPosition="@TableEditButtonPosition.End" EditTrigger="@TableEditTrigger.EditButton" >
                <HeaderContent>
                    <MudTh>@Localizer["Ready"]</MudTh>
                    <MudTh>@Localizer["Ingredient"]</MudTh>
                    <MudTh>@Localizer["Amount"]</MudTh>
                    <MudTh Class="d-flex align-content-end justify-content-end" colspan="2" >
                        <MudButton @onclick="AddIngredient" Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small">
                            @Localizer["NewIngredient"]
                        </MudButton>
                    </MudTh>
                </HeaderContent>
                <RowTemplate Context="ingredient">
                    <MudTd Style="text-align:right">
                        <MudCheckBox @bind-Checked="@IngredientDone[ingredient.Order]" Color="Color.Primary" Size="Size.Small"></MudCheckBox>
                    </MudTd>
                    <MudTd DataLabel="@Localizer["Ingredient"]">@ingredient.Name</MudTd>
                    <MudTd DataLabel="@Localizer["Amount"]">@ingredient.Amount</MudTd>
                    <MudTd DataLabel="Icons" Style="text-align:right">
                        <MudIcon Class="ma-0 cursor-pointer" Icon="@Icons.Material.Outlined.Delete" @onclick="@(async() => await DeleteIngredient(ingredient))" Size="Size.Small"></MudIcon>
                        <MudIconButton Size="@Size.Medium" Icon="@Icons.Material.Outlined.KeyboardArrowUp" Class="pa-0" OnClick="@(async() => await DecreaseIngredientOrder(ingredient))" />
                        <MudIconButton Size="@Size.Medium" Icon="@Icons.Material.Outlined.KeyboardArrowDown" Class="pa-0" OnClick="@(async() => await IncreaseIngredientOrder(ingredient))" />
                    </MudTd>
                </RowTemplate>
                <RowEditingTemplate Context="ingredient">
                    <MudCheckBox @bind-Checked="@IngredientDone[ingredient.Order]" Color="Color.Primary" Size="Size.Small"></MudCheckBox>
                    <MudTd DataLabel="@Localizer["Ingredient"]">
                        <MudTextField @bind-Value="@ingredient.Name" @ref="IngredientEditField" Immediate="true" OnKeyDown="async(e) => await OnIngredientNameKeyDown(e, ingredient)" />
                    </MudTd>
                    <MudTd DataLabel="@Localizer["Amount"]">
                        <MudTextField @bind-Value="@ingredient.Amount" @ref="IngredientAmountEditField" Immediate="true" OnKeyDown="async(e) => await OnIngredientAmountKeyDown(e, ingredient)" />
                    </MudTd>
                </RowEditingTemplate>
                <EditButtonContent Context="button">
                    <MudIconButton Size="@Size.Small" Icon="@Icons.Material.Outlined.Edit" Class="pa-0" OnClick="@button.ButtonAction" Disabled="@button.ButtonDisabled" />
                </EditButtonContent>
                </MudTable>
            </MudItem>
            <MudItem sm="12" md="6">
                <MudPaper Class="pa-1 mt-1" Elevation="0">
                @foreach (var step in _recipe.Steps.OrderBy(x => x.Order))
                {
                    var text = $"{step.Order}. {step.Description}";
                    var highlights = _recipe.Ingredients.SelectMany(x => x.Name.Split(" ")).SelectMany(LanguageDictionary.WordInflections);
                    <MudPaper Class="pa-0 ma-0" Outlined="true">
                        <MudStack Row="true" Justify="Justify.SpaceAround" Spacing="0">
                            @if (EditMode[step])
                            {
                                <MudTextField @ref="StepEditFields[step]" Text="@step.Description" Label="Description" Variant="Variant.Text" DebounceInterval="1000" Lines="3"
                                      ValueChanged="@(async(string s) => await UpdateStepDescription(step, s))" OnKeyDown="(e) => OnStepKeyDown(e, step)"  />
                            }
                            else if (StepDone[step.Order])
                            {
                                <MudText Class="ma-2 flex-fill" Style="overflow-wrap: anywhere">
                                    @(text.Length > 20 ? text.Substring(0, 20) + "..." : text)
                                </MudText>
                            }
                            else
                            {
                                <MudText Class="ma-2 flex-fill" Style="overflow-wrap: anywhere; white-space: pre-line">
                                    <MudHighlighter Class="mud-primary-text" Style="background-color:transparent;font-weight:bold"
                                        Text="@text"
                                        HighlightedTexts="@highlights" />
                                </MudText>
                            }
                            <MudIconButton Size="@Size.Medium" Icon="@Icons.Material.Outlined.Delete" Class="pa-0" OnClick="@(async() => await DeleteStep(step))" />
                            <MudToggleIconButton Size="@Size.Medium" Class="pa-0" Toggled="EditMode[step]"
                                                Icon="@Icons.Material.Outlined.Edit" Title="Edit" ToggledChanged="(e) => OnStepEditChanged(e, step)"
                                                ToggledIcon="@Icons.Material.Outlined.EditOff" ToggledTitle="On" />
                            <MudIconButton Size="@Size.Medium" Icon="@Icons.Material.Outlined.KeyboardArrowUp" Class="pa-0" OnClick="@(async() => await DecreaseStepOrder(step))" />
                            <MudIconButton Size="@Size.Medium" Icon="@Icons.Material.Outlined.KeyboardArrowDown" Class="pa-0" OnClick="@(async() => await IncreaseStepOrder(step))" />
                        </MudStack>
                    </MudPaper>
                }
                <br />
                <MudButton @onclick="AddStep" Variant="Variant.Filled" Color="Color.Primary">
                    @Localizer["NewStep"]
                </MudButton>
                <MudButton @onclick="FinishCooking" Variant="Variant.Filled" Color="Color.Success">
                    @Localizer["FinishCooking"]
                </MudButton>
            </MudPaper>
            </MudItem>
        </MudGrid>
    </Authorized>
    <NotAuthorized>
        <p>@Localizer["NotSignedIn"]</p>
    </NotAuthorized>
</AuthorizeView>
@code
{
    private enum ToFocus
    {
        Nothing,
        LastStep,
        Ingredient,
        SelectedStep
    }

    [Parameter]
    public string Name { get; set; } = "";

    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }
    private string _userIdentityName = "";

    private MudTable<Ingredient> _ingredientTable;

    private bool _loading = true;

    private Recipe _recipe = new Recipe();
    private Dictionary<Step, bool> EditMode = new Dictionary<Step, bool>();
    private Dictionary<int, bool> StepDone = new Dictionary<int, bool>();
    private Dictionary<int, bool> IngredientDone = new Dictionary<int, bool>();

    private Dictionary<Step, MudTextField<string>> StepEditFields = new Dictionary<Step, MudTextField<string>>();
    private MudTextField<string>? IngredientEditField;
    private MudTextField<string>? IngredientAmountEditField;
    private ToFocus Focus;
    private Step StepToFocus;
    private Ingredient? IngredientToFocus;

    private int Servings
    {
        get
        {
            return _recipe.Servings;
        }
        set
        {
            if (value == _recipe.Servings) return;
            _recipe.Servings = value;
            cts.Cancel();
            cts = new();
            Task.Run(() => UpdateRecipeDelayed(cts.Token));
        }
    }

    CancellationTokenSource cts = new();

    private async Task OnIngredientNameKeyDown(KeyboardEventArgs e, Ingredient ingredient)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            if (IngredientAmountEditField != null) await IngredientAmountEditField.FocusAsync();
            StateHasChanged();
        }
        else if (e.Key == "Delete" && e.CtrlKey)
        {
            await DeleteIngredient(ingredient);
            _ingredientTable?.SetEditingItem(null);
            StateHasChanged();
        }
        else if (e.Key == "Escape")
        {
            if (ingredient.Name == "" || ingredient.Name == null)
            {
                await DeleteIngredient(ingredient);
                _ingredientTable?.SetEditingItem(null);
                StateHasChanged();
            }
            else
            {
                _ingredientTable.SetEditingItem(null);
                StateHasChanged();
            }
        }
    }

    private async Task OnIngredientAmountKeyDown(KeyboardEventArgs e, Ingredient ingredient)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            CommitTableEdit(ingredient);
            _ingredientTable?.SetEditingItem(null);
            if (ingredient == _recipe.Ingredients.LastOrDefault())
            {
                await AddIngredient();
            }
            Focus = ToFocus.Ingredient;
            StateHasChanged();
        }
        else if (e.Key == "Delete" && e.CtrlKey)
        {
            await DeleteIngredient(ingredient);
            _ingredientTable?.SetEditingItem(null);
            StateHasChanged();
        }
        else if (e.Key == "Escape")
        {
            if (ingredient.Name == "" || ingredient.Name == null)
            {
                await DeleteIngredient(ingredient);
                _ingredientTable?.SetEditingItem(null);
                StateHasChanged();
            }
            else
            {
                _ingredientTable.SetEditingItem(null);
                StateHasChanged();
            }
        }
    }

    private async void OnStepKeyDown(KeyboardEventArgs e, Step step)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            if (StepEditFields[step].Text != null)
            {
                await UpdateStepDescription(step, StepEditFields[step].Text);
            }
            EditMode[step] = false;
            if (step == _recipe.Steps.LastOrDefault())
            {
                await AddStep();
            }
            StateHasChanged();
        }
        else if (e.Key == "Delete" && e.CtrlKey)
        {
            await DeleteStep(step);
            StateHasChanged();
        }
        else if (e.Key == "Escape")
        {
            if (StepEditFields[step].Text != null)
            {
                await UpdateStepDescription(step, StepEditFields[step].Text);
            }
            if (step.Description == "" || step.Description == null)
            {
                await DeleteStep(step);
                StateHasChanged();
            }
            else
            {
                EditMode[step] = false;
                StateHasChanged();
            }
        }
    }

    private void OnStepEditChanged(bool e, Step step)
    {
        EditMode[step] = e;

        if (!e) return;

        StepToFocus = step;
        Focus = ToFocus.SelectedStep;
    }

    private void UpdateRecipeDelayed(CancellationToken token)
    {
        Thread.Sleep(1000);
        if (token.IsCancellationRequested) return;
        Service.UpdateRecipeAsync(_recipe, _userIdentityName);
    }

    protected override async Task OnInitializedAsync()
    {
        LanguageNotifier.SubscribeLanguageChange(this);

        if (authenticationStateTask != null)
        {
            var user = (await authenticationStateTask).User;
            if (user.Identity != null)
            {
                _userIdentityName = user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "";
            }
        }

        await RefreshRecipe();
        _loading = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        switch (Focus)
        {
            case ToFocus.SelectedStep:
                await StepEditFields[StepToFocus].FocusAsync();
                break;
            case ToFocus.LastStep:
                await StepEditFields[_recipe.Steps.Last()].FocusAsync();
                break;
            case ToFocus.Ingredient:
                if (IngredientToFocus != null)
                {
                    _ingredientTable.SetSelectedItem(IngredientToFocus);
                    _ingredientTable.SetEditingItem(IngredientToFocus);
                    IngredientToFocus = null;
                    StateHasChanged();
                }
                if (IngredientEditField != null) await IngredientEditField.FocusAsync();
                break;
            default:
                break;
        }
        Focus = ToFocus.Nothing;
    }

    private void PreviewEditClick(object element)
    {
        var ingredient = (Ingredient)element;
        Focus = ToFocus.Ingredient;
        StateHasChanged();
    }

    private void CommitTableEdit(object element)
    {
        var ingredient = (Ingredient)element;
        var result = Task.Run(() => @Service.UpdateIngredientAsync(ingredient, _userIdentityName)).Result;
    }

    private async Task DeleteIngredient(Ingredient ingredient)
    {
        var result = await @Service.DeleteIngredientAsync(ingredient, _userIdentityName);
        int removedOrder = ingredient.Order;
        _recipe.Ingredients.Remove(ingredient);
        foreach (var itemToUpdate in _recipe.Ingredients.Where(i => i.Order > removedOrder))
        {
            itemToUpdate.Order--;
        }
        StateHasChanged();
    }

    private async Task RefreshRecipe()
    {
        _ingredientTable?.SetEditingItem(null);
        _recipe = await @Service.GetDetailedRecipeAsync(Name, _userIdentityName) ?? new Recipe();
        var stepsByOrder = _recipe.Steps.GroupBy(x => x.Order);
        var ingredientsByOrder = _recipe.Ingredients.GroupBy(x => x.Order);

        if (_recipe.Steps.Any() &&
            (stepsByOrder.Count() != _recipe.Steps.Count
            || _recipe.Steps.Max(x => x.Order) != _recipe.Steps.Count
            || _recipe.Steps.Min(x => x.Order) != 1))
        {
            var result = await @Service.FixStepsOrder(_recipe, _userIdentityName);
            _recipe = await @Service.GetDetailedRecipeAsync(Name, _userIdentityName) ?? new Recipe();
        }

        if (_recipe.Ingredients.Any() &&
            (ingredientsByOrder.Count() != _recipe.Ingredients.Count
            || _recipe.Ingredients.Max(x => x.Order) != _recipe.Ingredients.Count
            || _recipe.Ingredients.Min(x => x.Order) != 1))
        {
            var result = await @Service.FixIngredientsOrder(_recipe, _userIdentityName);
            _recipe = await @Service.GetDetailedRecipeAsync(Name, _userIdentityName) ?? new Recipe();
        }

        EditMode = _recipe.Steps.ToDictionary(x => x, x => false);
        StepDone = _recipe.Steps.ToDictionary(x => x.Order, x => false);
        IngredientDone = _recipe.Ingredients.ToDictionary(x => x.Order, x => false);
        StateHasChanged();
    }

    private async Task AddIngredient()
    {
        _ingredientTable?.SetEditingItem(null);
        var ingredient = new Ingredient()
        {
            RecipeId = _recipe.Id,
            Order = _recipe.Ingredients.Any() ? _recipe.Ingredients.Max(i => i.Order) + 1 : 1,
            Name = ""
        };
        var createResult = await @Service.CreateIngredientAsync(ingredient, _userIdentityName);
        _recipe.Ingredients.Add(ingredient);
        IngredientDone[ingredient.Order] = false;
        Focus = ToFocus.Ingredient;
        IngredientToFocus = ingredient;
        StateHasChanged();
    }

    private async Task AddStep()
    {
        var step = new Step()
        {
            RecipeId = _recipe.Id,
            Order = _recipe.Steps.Any() ? _recipe.Steps.Max(s => s.Order) + 1 : 1
        };
        var createResult = await @Service.CreateStepAsync(step, _userIdentityName);
        _recipe.Steps.Add(step);
        EditMode[step] = true;
        StepDone[step.Order] = false;
        Focus = ToFocus.LastStep;
        StateHasChanged();
    }

    private async Task DeleteStep(Step step)
    {
        var result = await @Service.DeleteStepAsync(step, _userIdentityName);
        int removedOrder = step.Order;
        _recipe.Steps.Remove(step);
        EditMode.Remove(step);

        foreach (var itemToUpdate in _recipe.Steps.Where(s => s.Order > removedOrder))
        {
            itemToUpdate.Order--;
        }

        StateHasChanged();
    }

    private async Task UpdateStepDescription(Step step, string description)
    {
        step.Description = description;
        var result = await @Service.UpdateStepDescriptionAsync(step, _userIdentityName);
    }

    private async Task DecreaseIngredientOrder(Ingredient ingredient)
    {
        if (ingredient.Order <= 1) return;
        var result = await @Service.DecreaseIngredientOrder(ingredient, _userIdentityName);
        var otherIngredient = _recipe.Ingredients.FirstOrDefault(i => i.Order == ingredient.Order - 1);

        if (otherIngredient != null)
        {
            ingredient.Order--;
            otherIngredient.Order++;
            StateHasChanged();
        }
    }

    private async Task IncreaseIngredientOrder(Ingredient ingredient)
    {
        if (ingredient.Order >= _recipe.Ingredients.Count) return;
        var result = await @Service.IncreaseIngredientOrder(ingredient, _userIdentityName);
        var otherIngredient = _recipe.Ingredients.FirstOrDefault(i => i.Order == ingredient.Order + 1);

        if (otherIngredient != null)
        {
            ingredient.Order++;
            otherIngredient.Order--;
            StateHasChanged();
        }
    }

    private async Task DecreaseStepOrder(Step step)
    {
        if (step.Order <= 1) return;
        var result = await @Service.DecreaseStepOrder(step, _userIdentityName);

        var otherStep = _recipe.Steps.FirstOrDefault(s => s.Order == step.Order - 1);
        if (otherStep != null)
        {
            step.Order--;
            otherStep.Order++;
            StateHasChanged();
        }
    }

    private async Task IncreaseStepOrder(Step step)
    {
        if (step.Order >= _recipe.Steps.Count) return;
        var result = await @Service.IncreaseStepOrder(step, _userIdentityName);

        var otherStep = _recipe.Steps.FirstOrDefault(s => s.Order == step.Order + 1);
        if (otherStep != null)
        {
            step.Order++;
            otherStep.Order--;
            StateHasChanged();
        }
    }

    private void FinishCooking()
    {
        var result = Task.Run(() => @Service.UpdateRecipeLastCookedAsync(_recipe, _userIdentityName)).Result;
        NavigationManager.NavigateTo("");
    }

    private async Task ShareRecipe()
    {
        try
        {
            var options = new DialogOptions { CloseOnEscapeKey = true };
            var parameters = new DialogParameters<RecipeShareDialog>();
            parameters.Add(x => x.Recipe, _recipe);
            var dialog = await DialogService.ShowAsync<RecipeShareDialog>(Localizer["Share"], parameters, options);
            var dialogResult = await dialog.Result;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to share recipe.");
        }
    }

    public void Dispose() => LanguageNotifier.UnsubscribeLanguageChange(this);
}